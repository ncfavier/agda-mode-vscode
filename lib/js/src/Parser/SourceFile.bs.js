// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");

function parse(filepath) {
  if (/\.lagda\.rst$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateRST";
  } else if (/\.lagda\.md$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateMarkdown";
  } else if (/\.lagda\.tex$|\.lagda$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateTeX";
  } else if (/\.lagda\.org$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateOrg";
  } else {
    return "Agda";
  }
}

var FileType = {
  parse: parse
};

function isHole(token) {
  var match = token.kind;
  switch (match) {
    case "GoalBracket" :
    case "GoalQM" :
        return true;
    default:
      return false;
  }
}

var Token = {
  isHole: isHole
};

function make(raw) {
  return [{
            content: raw,
            range: [
              0,
              raw.length
            ],
            kind: "AgdaRaw"
          }];
}

function lex(regex, source, target, tokens) {
  var f = function (token) {
    if (token.kind !== source) {
      return [token];
    }
    var cursor = {
      contents: token.range[0]
    };
    return Core__Array.filterMap(token.content.split(regex), (function (x) {
                    return x;
                  })).map(function (content) {
                var kind = regex.test(content) ? target : source;
                var cursorOld = cursor.contents;
                cursor.contents = cursor.contents + content.length | 0;
                return {
                        content: content,
                        range: [
                          cursorOld,
                          cursor.contents
                        ],
                        kind: kind
                      };
              });
  };
  return tokens.map(f).flat();
}

function map(f, self) {
  var delta = {
    contents: 0
  };
  return self.map(function (token) {
              var match = f(token);
              var content = match.content;
              var match$1 = token.range;
              var lengthDiff = content.length - token.content.length | 0;
              var result_range = [
                match$1[0] + delta.contents | 0,
                (match$1[1] + delta.contents | 0) + lengthDiff | 0
              ];
              var result_kind = match.kind;
              var result = {
                content: content,
                range: result_range,
                kind: result_kind
              };
              delta.contents = delta.contents + lengthDiff | 0;
              return result;
            });
}

function mapOnly(kind, f, self) {
  return map((function (token) {
                if (token.kind === kind) {
                  return f(token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = /\\begin\{code\}.*/;

var texEnd = /\\end\{code\}.*/;

var markdown = /\`\`\`(agda)?/;

var rstBegin = /\:\:/;

var rstEnd = /^[^\s]/;

var orgBegin = /\#\+begin\_src agda2/i;

var orgEnd = /\#\+end\_src/i;

var comment = /((?<=^|[\s\"\_\;\.\(\)\{\}\@])--[^\r\n]*(?:\r|\n|$))|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/;

var goalBracket = /(\{\!(?:(?!\!\})(?:.|\s))*\!\})/;

var goalQuestionMarkRaw = /([\s\(\{\_\;\.\\\"@]|^)(\?)([\s\)\}\_\;\.\\\"@]|$)/gm;

var goalQuestionMark = /(\?)/;

var goalBracketContent = /\{\!((?:(?!\!\})(?:.|\s))*)\!\}/;

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  rstBegin: rstBegin,
  rstEnd: rstEnd,
  orgBegin: orgBegin,
  orgEnd: orgEnd,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function toTokens(raw) {
  var cursor = {
    contents: 0
  };
  return Core__Option.mapOr(Caml_option.nullable_to_opt(raw.match(/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g)), [], (function (lines) {
                return lines.map(function (x) {
                                if (x !== undefined) {
                                  return x;
                                } else {
                                  return "";
                                }
                              }).filter(function (s) {
                              return s !== "";
                            }).map(function (line) {
                            var cursorOld = cursor.contents;
                            cursor.contents = cursor.contents + line.length | 0;
                            return {
                                    content: raw.substring(cursorOld, cursor.contents),
                                    range: [
                                      cursorOld,
                                      cursor.contents
                                    ],
                                    kind: "Literate"
                                  };
                          });
              }));
}

function markWithRules(begin_, end_, raw) {
  var previous = {
    contents: false
  };
  var current = {
    contents: false
  };
  return toTokens(raw).map(function (token) {
              var content = token.content;
              previous.contents = current.contents;
              if (begin_.test(content) && !current.contents) {
                current.contents = true;
              } else if (end_.test(content) && current.contents) {
                current.contents = false;
              }
              var insideAgda = previous.contents && current.contents;
              var kind = insideAgda ? "AgdaRaw" : "Literate";
              return {
                      content: content,
                      range: token.range,
                      kind: kind
                    };
            });
}

function markMarkdown(extra) {
  return markWithRules(markdown, markdown, extra);
}

function markTex(extra) {
  return markWithRules(texBegin, texEnd, extra);
}

function markRST(extra) {
  return markWithRules(rstBegin, rstEnd, extra);
}

function markOrg(extra) {
  return markWithRules(orgBegin, orgEnd, extra);
}

var Literate = {
  toTokens: toTokens,
  markWithRules: markWithRules,
  markMarkdown: markMarkdown,
  markTex: markTex,
  markRST: markRST,
  markOrg: markOrg
};

function toString(param) {
  var originalInterval = param.originalInterval;
  var modifiedInterval = param.modifiedInterval;
  return "Hole [" + (String(param.index) + ("] (" + (String(originalInterval[0]) + (", " + (String(originalInterval[1]) + (") => (" + (String(modifiedInterval[0]) + (", " + (String(modifiedInterval[1]) + (") \"" + (param.content + "\"")))))))))));
}

var Diff = {
  toString: toString
};

function parse$1(indices, filepath, raw) {
  var fileType = parse(filepath);
  var preprocessed;
  switch (fileType) {
    case "Agda" :
        preprocessed = make(raw);
        break;
    case "LiterateTeX" :
        preprocessed = markWithRules(texBegin, texEnd, raw);
        break;
    case "LiterateRST" :
        preprocessed = markWithRules(rstBegin, rstEnd, raw);
        break;
    case "LiterateMarkdown" :
        preprocessed = markWithRules(markdown, markdown, raw);
        break;
    case "LiterateOrg" :
        preprocessed = markWithRules(orgBegin, orgEnd, raw);
        break;
    
  }
  var original = lex(goalQuestionMark, "GoalQMRaw", "GoalQM", lex(goalQuestionMarkRaw, "AgdaRaw", "GoalQMRaw", lex(goalBracket, "AgdaRaw", "GoalBracket", lex(comment, "AgdaRaw", "Comment", preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return {
            content: "{!   !}",
            range: token.range,
            kind: "GoalBracket"
          };
  };
  var modified = mapOnly("GoalQM", questionMark2GoalBracket, original);
  var originalHoles = original.filter(isHole);
  var modifiedHoles = modified.filter(isHole);
  return Core__Array.filterMap(originalHoles.map(function (token, idx) {
                  var match = modifiedHoles[idx];
                  var match$1 = indices[idx];
                  if (match === undefined) {
                    return ;
                  }
                  if (match$1 === undefined) {
                    return ;
                  }
                  var match$2 = match.range;
                  var start = match$2[0];
                  return {
                          index: match$1,
                          modifiedInterval: match.range,
                          originalInterval: [
                            start,
                            start + token.content.length | 0
                          ],
                          content: match.content,
                          changed: token.content !== match.content
                        };
                }), (function (x) {
                return x;
              }));
}

exports.FileType = FileType;
exports.Token = Token;
exports.Lexer = Lexer;
exports.Regex = Regex;
exports.Literate = Literate;
exports.Diff = Diff;
exports.parse = parse$1;
/* Parser-AgdaModeVscode Not a pure module */
